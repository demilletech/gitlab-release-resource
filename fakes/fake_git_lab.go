// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	sync "sync"

	resource "github.com/edtan/gitlab-release-resource"
	gitlab "github.com/xanzy/go-gitlab"
)

type FakeGitLab struct {
	CreateReleaseStub        func(string, string) (*gitlab.Release, error)
	createReleaseMutex       sync.RWMutex
	createReleaseArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createReleaseReturns struct {
		result1 *gitlab.Release
		result2 error
	}
	createReleaseReturnsOnCall map[int]struct {
		result1 *gitlab.Release
		result2 error
	}
	CreateTagStub        func(string, string) (*gitlab.Tag, error)
	createTagMutex       sync.RWMutex
	createTagArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createTagReturns struct {
		result1 *gitlab.Tag
		result2 error
	}
	createTagReturnsOnCall map[int]struct {
		result1 *gitlab.Tag
		result2 error
	}
	DownloadProjectFileStub        func(string, string) error
	downloadProjectFileMutex       sync.RWMutex
	downloadProjectFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	downloadProjectFileReturns struct {
		result1 error
	}
	downloadProjectFileReturnsOnCall map[int]struct {
		result1 error
	}
	GetTagStub        func(string) (*gitlab.Tag, error)
	getTagMutex       sync.RWMutex
	getTagArgsForCall []struct {
		arg1 string
	}
	getTagReturns struct {
		result1 *gitlab.Tag
		result2 error
	}
	getTagReturnsOnCall map[int]struct {
		result1 *gitlab.Tag
		result2 error
	}
	ListTagsStub        func() ([]*gitlab.Tag, error)
	listTagsMutex       sync.RWMutex
	listTagsArgsForCall []struct {
	}
	listTagsReturns struct {
		result1 []*gitlab.Tag
		result2 error
	}
	listTagsReturnsOnCall map[int]struct {
		result1 []*gitlab.Tag
		result2 error
	}
	ListTagsUntilStub        func(string) ([]*gitlab.Tag, error)
	listTagsUntilMutex       sync.RWMutex
	listTagsUntilArgsForCall []struct {
		arg1 string
	}
	listTagsUntilReturns struct {
		result1 []*gitlab.Tag
		result2 error
	}
	listTagsUntilReturnsOnCall map[int]struct {
		result1 []*gitlab.Tag
		result2 error
	}
	UpdateReleaseStub        func(string, string) (*gitlab.Release, error)
	updateReleaseMutex       sync.RWMutex
	updateReleaseArgsForCall []struct {
		arg1 string
		arg2 string
	}
	updateReleaseReturns struct {
		result1 *gitlab.Release
		result2 error
	}
	updateReleaseReturnsOnCall map[int]struct {
		result1 *gitlab.Release
		result2 error
	}
	UploadProjectFileStub        func(string) (*gitlab.ProjectFile, error)
	uploadProjectFileMutex       sync.RWMutex
	uploadProjectFileArgsForCall []struct {
		arg1 string
	}
	uploadProjectFileReturns struct {
		result1 *gitlab.ProjectFile
		result2 error
	}
	uploadProjectFileReturnsOnCall map[int]struct {
		result1 *gitlab.ProjectFile
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeGitLab) CreateRelease(arg1 string, arg2 string) (*gitlab.Release, error) {
	fake.createReleaseMutex.Lock()
	ret, specificReturn := fake.createReleaseReturnsOnCall[len(fake.createReleaseArgsForCall)]
	fake.createReleaseArgsForCall = append(fake.createReleaseArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("CreateRelease", []interface{}{arg1, arg2})
	fake.createReleaseMutex.Unlock()
	if fake.CreateReleaseStub != nil {
		return fake.CreateReleaseStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createReleaseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitLab) CreateReleaseCallCount() int {
	fake.createReleaseMutex.RLock()
	defer fake.createReleaseMutex.RUnlock()
	return len(fake.createReleaseArgsForCall)
}

func (fake *FakeGitLab) CreateReleaseCalls(stub func(string, string) (*gitlab.Release, error)) {
	fake.createReleaseMutex.Lock()
	defer fake.createReleaseMutex.Unlock()
	fake.CreateReleaseStub = stub
}

func (fake *FakeGitLab) CreateReleaseArgsForCall(i int) (string, string) {
	fake.createReleaseMutex.RLock()
	defer fake.createReleaseMutex.RUnlock()
	argsForCall := fake.createReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGitLab) CreateReleaseReturns(result1 *gitlab.Release, result2 error) {
	fake.createReleaseMutex.Lock()
	defer fake.createReleaseMutex.Unlock()
	fake.CreateReleaseStub = nil
	fake.createReleaseReturns = struct {
		result1 *gitlab.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) CreateReleaseReturnsOnCall(i int, result1 *gitlab.Release, result2 error) {
	fake.createReleaseMutex.Lock()
	defer fake.createReleaseMutex.Unlock()
	fake.CreateReleaseStub = nil
	if fake.createReleaseReturnsOnCall == nil {
		fake.createReleaseReturnsOnCall = make(map[int]struct {
			result1 *gitlab.Release
			result2 error
		})
	}
	fake.createReleaseReturnsOnCall[i] = struct {
		result1 *gitlab.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) CreateTag(arg1 string, arg2 string) (*gitlab.Tag, error) {
	fake.createTagMutex.Lock()
	ret, specificReturn := fake.createTagReturnsOnCall[len(fake.createTagArgsForCall)]
	fake.createTagArgsForCall = append(fake.createTagArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("CreateTag", []interface{}{arg1, arg2})
	fake.createTagMutex.Unlock()
	if fake.CreateTagStub != nil {
		return fake.CreateTagStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createTagReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitLab) CreateTagCallCount() int {
	fake.createTagMutex.RLock()
	defer fake.createTagMutex.RUnlock()
	return len(fake.createTagArgsForCall)
}

func (fake *FakeGitLab) CreateTagCalls(stub func(string, string) (*gitlab.Tag, error)) {
	fake.createTagMutex.Lock()
	defer fake.createTagMutex.Unlock()
	fake.CreateTagStub = stub
}

func (fake *FakeGitLab) CreateTagArgsForCall(i int) (string, string) {
	fake.createTagMutex.RLock()
	defer fake.createTagMutex.RUnlock()
	argsForCall := fake.createTagArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGitLab) CreateTagReturns(result1 *gitlab.Tag, result2 error) {
	fake.createTagMutex.Lock()
	defer fake.createTagMutex.Unlock()
	fake.CreateTagStub = nil
	fake.createTagReturns = struct {
		result1 *gitlab.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) CreateTagReturnsOnCall(i int, result1 *gitlab.Tag, result2 error) {
	fake.createTagMutex.Lock()
	defer fake.createTagMutex.Unlock()
	fake.CreateTagStub = nil
	if fake.createTagReturnsOnCall == nil {
		fake.createTagReturnsOnCall = make(map[int]struct {
			result1 *gitlab.Tag
			result2 error
		})
	}
	fake.createTagReturnsOnCall[i] = struct {
		result1 *gitlab.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) DownloadProjectFile(arg1 string, arg2 string) error {
	fake.downloadProjectFileMutex.Lock()
	ret, specificReturn := fake.downloadProjectFileReturnsOnCall[len(fake.downloadProjectFileArgsForCall)]
	fake.downloadProjectFileArgsForCall = append(fake.downloadProjectFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("DownloadProjectFile", []interface{}{arg1, arg2})
	fake.downloadProjectFileMutex.Unlock()
	if fake.DownloadProjectFileStub != nil {
		return fake.DownloadProjectFileStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.downloadProjectFileReturns
	return fakeReturns.result1
}

func (fake *FakeGitLab) DownloadProjectFileCallCount() int {
	fake.downloadProjectFileMutex.RLock()
	defer fake.downloadProjectFileMutex.RUnlock()
	return len(fake.downloadProjectFileArgsForCall)
}

func (fake *FakeGitLab) DownloadProjectFileCalls(stub func(string, string) error) {
	fake.downloadProjectFileMutex.Lock()
	defer fake.downloadProjectFileMutex.Unlock()
	fake.DownloadProjectFileStub = stub
}

func (fake *FakeGitLab) DownloadProjectFileArgsForCall(i int) (string, string) {
	fake.downloadProjectFileMutex.RLock()
	defer fake.downloadProjectFileMutex.RUnlock()
	argsForCall := fake.downloadProjectFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGitLab) DownloadProjectFileReturns(result1 error) {
	fake.downloadProjectFileMutex.Lock()
	defer fake.downloadProjectFileMutex.Unlock()
	fake.DownloadProjectFileStub = nil
	fake.downloadProjectFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitLab) DownloadProjectFileReturnsOnCall(i int, result1 error) {
	fake.downloadProjectFileMutex.Lock()
	defer fake.downloadProjectFileMutex.Unlock()
	fake.DownloadProjectFileStub = nil
	if fake.downloadProjectFileReturnsOnCall == nil {
		fake.downloadProjectFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.downloadProjectFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeGitLab) GetTag(arg1 string) (*gitlab.Tag, error) {
	fake.getTagMutex.Lock()
	ret, specificReturn := fake.getTagReturnsOnCall[len(fake.getTagArgsForCall)]
	fake.getTagArgsForCall = append(fake.getTagArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetTag", []interface{}{arg1})
	fake.getTagMutex.Unlock()
	if fake.GetTagStub != nil {
		return fake.GetTagStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getTagReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitLab) GetTagCallCount() int {
	fake.getTagMutex.RLock()
	defer fake.getTagMutex.RUnlock()
	return len(fake.getTagArgsForCall)
}

func (fake *FakeGitLab) GetTagCalls(stub func(string) (*gitlab.Tag, error)) {
	fake.getTagMutex.Lock()
	defer fake.getTagMutex.Unlock()
	fake.GetTagStub = stub
}

func (fake *FakeGitLab) GetTagArgsForCall(i int) string {
	fake.getTagMutex.RLock()
	defer fake.getTagMutex.RUnlock()
	argsForCall := fake.getTagArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitLab) GetTagReturns(result1 *gitlab.Tag, result2 error) {
	fake.getTagMutex.Lock()
	defer fake.getTagMutex.Unlock()
	fake.GetTagStub = nil
	fake.getTagReturns = struct {
		result1 *gitlab.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) GetTagReturnsOnCall(i int, result1 *gitlab.Tag, result2 error) {
	fake.getTagMutex.Lock()
	defer fake.getTagMutex.Unlock()
	fake.GetTagStub = nil
	if fake.getTagReturnsOnCall == nil {
		fake.getTagReturnsOnCall = make(map[int]struct {
			result1 *gitlab.Tag
			result2 error
		})
	}
	fake.getTagReturnsOnCall[i] = struct {
		result1 *gitlab.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) ListTags() ([]*gitlab.Tag, error) {
	fake.listTagsMutex.Lock()
	ret, specificReturn := fake.listTagsReturnsOnCall[len(fake.listTagsArgsForCall)]
	fake.listTagsArgsForCall = append(fake.listTagsArgsForCall, struct {
	}{})
	fake.recordInvocation("ListTags", []interface{}{})
	fake.listTagsMutex.Unlock()
	if fake.ListTagsStub != nil {
		return fake.ListTagsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listTagsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitLab) ListTagsCallCount() int {
	fake.listTagsMutex.RLock()
	defer fake.listTagsMutex.RUnlock()
	return len(fake.listTagsArgsForCall)
}

func (fake *FakeGitLab) ListTagsCalls(stub func() ([]*gitlab.Tag, error)) {
	fake.listTagsMutex.Lock()
	defer fake.listTagsMutex.Unlock()
	fake.ListTagsStub = stub
}

func (fake *FakeGitLab) ListTagsReturns(result1 []*gitlab.Tag, result2 error) {
	fake.listTagsMutex.Lock()
	defer fake.listTagsMutex.Unlock()
	fake.ListTagsStub = nil
	fake.listTagsReturns = struct {
		result1 []*gitlab.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) ListTagsReturnsOnCall(i int, result1 []*gitlab.Tag, result2 error) {
	fake.listTagsMutex.Lock()
	defer fake.listTagsMutex.Unlock()
	fake.ListTagsStub = nil
	if fake.listTagsReturnsOnCall == nil {
		fake.listTagsReturnsOnCall = make(map[int]struct {
			result1 []*gitlab.Tag
			result2 error
		})
	}
	fake.listTagsReturnsOnCall[i] = struct {
		result1 []*gitlab.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) ListTagsUntil(arg1 string) ([]*gitlab.Tag, error) {
	fake.listTagsUntilMutex.Lock()
	ret, specificReturn := fake.listTagsUntilReturnsOnCall[len(fake.listTagsUntilArgsForCall)]
	fake.listTagsUntilArgsForCall = append(fake.listTagsUntilArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ListTagsUntil", []interface{}{arg1})
	fake.listTagsUntilMutex.Unlock()
	if fake.ListTagsUntilStub != nil {
		return fake.ListTagsUntilStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.listTagsUntilReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitLab) ListTagsUntilCallCount() int {
	fake.listTagsUntilMutex.RLock()
	defer fake.listTagsUntilMutex.RUnlock()
	return len(fake.listTagsUntilArgsForCall)
}

func (fake *FakeGitLab) ListTagsUntilCalls(stub func(string) ([]*gitlab.Tag, error)) {
	fake.listTagsUntilMutex.Lock()
	defer fake.listTagsUntilMutex.Unlock()
	fake.ListTagsUntilStub = stub
}

func (fake *FakeGitLab) ListTagsUntilArgsForCall(i int) string {
	fake.listTagsUntilMutex.RLock()
	defer fake.listTagsUntilMutex.RUnlock()
	argsForCall := fake.listTagsUntilArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitLab) ListTagsUntilReturns(result1 []*gitlab.Tag, result2 error) {
	fake.listTagsUntilMutex.Lock()
	defer fake.listTagsUntilMutex.Unlock()
	fake.ListTagsUntilStub = nil
	fake.listTagsUntilReturns = struct {
		result1 []*gitlab.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) ListTagsUntilReturnsOnCall(i int, result1 []*gitlab.Tag, result2 error) {
	fake.listTagsUntilMutex.Lock()
	defer fake.listTagsUntilMutex.Unlock()
	fake.ListTagsUntilStub = nil
	if fake.listTagsUntilReturnsOnCall == nil {
		fake.listTagsUntilReturnsOnCall = make(map[int]struct {
			result1 []*gitlab.Tag
			result2 error
		})
	}
	fake.listTagsUntilReturnsOnCall[i] = struct {
		result1 []*gitlab.Tag
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) UpdateRelease(arg1 string, arg2 string) (*gitlab.Release, error) {
	fake.updateReleaseMutex.Lock()
	ret, specificReturn := fake.updateReleaseReturnsOnCall[len(fake.updateReleaseArgsForCall)]
	fake.updateReleaseArgsForCall = append(fake.updateReleaseArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("UpdateRelease", []interface{}{arg1, arg2})
	fake.updateReleaseMutex.Unlock()
	if fake.UpdateReleaseStub != nil {
		return fake.UpdateReleaseStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateReleaseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitLab) UpdateReleaseCallCount() int {
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	return len(fake.updateReleaseArgsForCall)
}

func (fake *FakeGitLab) UpdateReleaseCalls(stub func(string, string) (*gitlab.Release, error)) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = stub
}

func (fake *FakeGitLab) UpdateReleaseArgsForCall(i int) (string, string) {
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	argsForCall := fake.updateReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeGitLab) UpdateReleaseReturns(result1 *gitlab.Release, result2 error) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = nil
	fake.updateReleaseReturns = struct {
		result1 *gitlab.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) UpdateReleaseReturnsOnCall(i int, result1 *gitlab.Release, result2 error) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = nil
	if fake.updateReleaseReturnsOnCall == nil {
		fake.updateReleaseReturnsOnCall = make(map[int]struct {
			result1 *gitlab.Release
			result2 error
		})
	}
	fake.updateReleaseReturnsOnCall[i] = struct {
		result1 *gitlab.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) UploadProjectFile(arg1 string) (*gitlab.ProjectFile, error) {
	fake.uploadProjectFileMutex.Lock()
	ret, specificReturn := fake.uploadProjectFileReturnsOnCall[len(fake.uploadProjectFileArgsForCall)]
	fake.uploadProjectFileArgsForCall = append(fake.uploadProjectFileArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("UploadProjectFile", []interface{}{arg1})
	fake.uploadProjectFileMutex.Unlock()
	if fake.UploadProjectFileStub != nil {
		return fake.UploadProjectFileStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.uploadProjectFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeGitLab) UploadProjectFileCallCount() int {
	fake.uploadProjectFileMutex.RLock()
	defer fake.uploadProjectFileMutex.RUnlock()
	return len(fake.uploadProjectFileArgsForCall)
}

func (fake *FakeGitLab) UploadProjectFileCalls(stub func(string) (*gitlab.ProjectFile, error)) {
	fake.uploadProjectFileMutex.Lock()
	defer fake.uploadProjectFileMutex.Unlock()
	fake.UploadProjectFileStub = stub
}

func (fake *FakeGitLab) UploadProjectFileArgsForCall(i int) string {
	fake.uploadProjectFileMutex.RLock()
	defer fake.uploadProjectFileMutex.RUnlock()
	argsForCall := fake.uploadProjectFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeGitLab) UploadProjectFileReturns(result1 *gitlab.ProjectFile, result2 error) {
	fake.uploadProjectFileMutex.Lock()
	defer fake.uploadProjectFileMutex.Unlock()
	fake.UploadProjectFileStub = nil
	fake.uploadProjectFileReturns = struct {
		result1 *gitlab.ProjectFile
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) UploadProjectFileReturnsOnCall(i int, result1 *gitlab.ProjectFile, result2 error) {
	fake.uploadProjectFileMutex.Lock()
	defer fake.uploadProjectFileMutex.Unlock()
	fake.UploadProjectFileStub = nil
	if fake.uploadProjectFileReturnsOnCall == nil {
		fake.uploadProjectFileReturnsOnCall = make(map[int]struct {
			result1 *gitlab.ProjectFile
			result2 error
		})
	}
	fake.uploadProjectFileReturnsOnCall[i] = struct {
		result1 *gitlab.ProjectFile
		result2 error
	}{result1, result2}
}

func (fake *FakeGitLab) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createReleaseMutex.RLock()
	defer fake.createReleaseMutex.RUnlock()
	fake.createTagMutex.RLock()
	defer fake.createTagMutex.RUnlock()
	fake.downloadProjectFileMutex.RLock()
	defer fake.downloadProjectFileMutex.RUnlock()
	fake.getTagMutex.RLock()
	defer fake.getTagMutex.RUnlock()
	fake.listTagsMutex.RLock()
	defer fake.listTagsMutex.RUnlock()
	fake.listTagsUntilMutex.RLock()
	defer fake.listTagsUntilMutex.RUnlock()
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	fake.uploadProjectFileMutex.RLock()
	defer fake.uploadProjectFileMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeGitLab) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ resource.GitLab = new(FakeGitLab)
